---
# 포스트제목
title: "JPA 하이버네이트 스터디"
# 포스팅 작성자
author: ["이동옥"] 
# 포스팅 공개일 - 정렬기준 포스팅날짜순서에 따라 기재됨.(주의 미래날짜는 기입X)
date: 2020-04-12 08:26:28 -0400
# 블로그 메인페이지에 썸네일과 함께 노출될 텍스트 설정 일정 길이를 초과하면 잘려서 표시됨.
# abstract:
# 태그를 입력
tags: ["jpa","하이버네이트"]
categories: jpa
# 대표 이미지를 입력합니다. 이미지 업로드 위치는 아래에 기술합니다.
# image: /assets/images/posts/nerdfactory-documentation-history/main.jpg
# 포스트의 초안 여부를 입력합니다. "no" 로 입력할 경우 공개됩니다.
draft: "no"
---

## JPA 장단점

### ORM 정의 - 객체관계맵핑
 - 객체는 객체대로 설계
 - 관계형 데이터베이스는 관계형 데이터베이스대로 설계
 - ORM프레임워크가 중간에서 맵핑
 
하이버네이트

### jpa 예시 마이바티스 비교
저장 : jpa.persist(member)
조회 : Member member = jpa.find(memberId)
수정 : member.setName("변경할 이름")
삭제 : jpa.remove(member)

### jpa설정에서 방법을 선택할 수 있음. 성능에따라 설정
 - 지연로딩

 - 즉시로딩

```
장점
 - 생산성
Hibernate는 SQL를 직접 사용하지 않고, 메서드 호출만으로 쿼리가 수행됩니다.
즉, SQL 반복 작업을 하지 않으므로 생산성이 매우 높아집니다.
그런데 SQL을 직접 사용하지 않는다고 해서 SQL을 몰라도 된다는 것은 아닙니다.
Hibernate가 수행한 쿼리를 콘솔로 출력하도록 설정을 할 수 있는데, 쿼리를 보면서 의도한 대로 쿼리가 짜여졌는지, 성능은 어떠한지에 대한 모니터링이 필요하기 때문에 SQL을 잘 알아야 합니다.
 - 유지보수
테이블 컬럼이 하나 변경되었을 경우,
Mybatis에서는 관련 DAO의 파라미터, 결과, SQL 등을 모두 확인하여 수정해야 함
JPA를 사용하면 JPA가 이런 일들을 대신해주기 때문에 유지보수 측면에서 좋습니다.
 - 특정 벤더에 종속적이지 않음
여러 DB 벤더( MySQL, Oracle 등.. )마다 SQL 사용이 조금씩 다르기 때문에 애플리케이션 개발 시 처음 선택한 DB를 나중에 바꾸는 것은 매우 어렵습니다.
그런데 JPA는 추상화된 데이터 접근 계층을 제공하기 때문에 특정 벤더에 종속적이지 않습니다.
즉, 설정 파일에서 JPA에게 어떤 DB를 사용하고 있는지 알려주기만 하면 얼마든지 DB를 바꿀 수가 있습니다.


단점
 - 성능
메서드 호출로 쿼리를 실행한다는 것은 내부적으로 많은 동작이 있다는 것을 의미하므로, 직접 SQL을 호출하는 것보다 성능이 떨어질 수 있습니다.
실제로 초기의 ORM은 쿼리가 제대로 수행되지 않았고, 성능도 좋지 못했다고 합니다.
그러나 지금은 많이 발전하여, 좋은 성능을 보여주고 있고 계속 발전하고 있습니다.
 - 세밀함
메서드 호출로 SQL을 실행하기 때문에 세밀함이 떨어집니다. 또한 객체간의 매핑( Entity Mapping )이 잘못되거나 JPA를 잘못 사용하여 의도하지 않은 동작을 할 수도 있구요.
복잡한 통계 분석 쿼리를 메서드 호출로 처리하는 것은 힘든 일입니다.
이것을 보완하기 위해 JPA에서는 SQL과 유사한 기술인 JPQL을 지원합니다.
물론 SQL 자체 쿼리를 작성할 수 있도록 지원도 하고 있습니다.
 - 러닝커브
JPA를 잘 사용하기 위해서는 알아야 할 것이 많습니다.
그래서 이러한 복잡성을 해결하고자 최근에는 Spring Data JDBC가 주목을 받고 있습니다.
```

## 명령어

```
JPA 어노테이션 종류
@Entity : JPA 엔티티 클래스 라는 선언, final enum interface 사용 안됨.
@Table : 매핑할 클래스 정보,
@Id : 엔티티 클래스의 PK값,
@Column : 매핑할 테이블 컬럼명을 name 속서의로 매핑하는 용도 name 생략시, 필드의 이름을 따름

@ManyToOne : N:1 매핑
@OneToOne : 1:1 매핑
@OneToMany : 1:N 매핑
@ManyToMany : N:M 매핑

p.s ) JPA에서는 주인쪽이 외래키를 관리하고
보통 DB에서는 1:N관계에서 N쪽이 외래키를 관리한다.
ManyToOne 관계에서는 Many쪽에 외래키가 생성되고
OneToMany 관계에서도 Many쪽에 외래키가 생성된다.
JoinColumn 생성 위치랑은 별도로 그렇다.

@JoinColumn : Join에 쓰일 외래키 지정, name에 매핑할 외래키를 지정한다.
@JoinTable : M:N 관계에서 중간 경유 테이블 지정할때 쓰임
@JoinTable.name : 연결 테이블 지정
@JoinTable.joinColumns:현재 방향에서 매핑할 연결 테이블의 컬럼명 지정
@JoinTable.inverseJoinColumns : 반대 방향에서 매핑할 연결 테이블의 컬렴명을 지정, Join컬럼처럼 owner쪽에서 선언해주면됨,

referencedColumnName은 외래키가 참조하는 대상 테이블 명을 따로 지정할때 쓰이는 속성이다.

@IdClass(Class.class) : 복합 기본키 선언
PK가 여러 key로 이루어진 테이블을 복합 기본키 라고 부름.
복합 기본 키를 이용하기 위해선 엔티티 위에 이 어노테이션을 붙여야한다.

@Inheritance : 상속 매핑,
Inheritance.strategy : 상속 매핑 전략 지정

@DiscriminatorColumn : 부모 클래스에 구분 컬럼 지정,
DiscriminatorColumn.name 컬럼명 지정

@DiscriminatorValue : 엔티티 저장시, 구분 컬럼에 입력할 값 지정

Inheritance,DiscriminatorColumn,DiscriminatorValue 모두
SuperType SubType relationShip 모델링 기법을 사용할때 쓰임

Inheritance는 조인 전략을 지정하고,

DiscriminatorColumn은 테이블의 타입을 지정하여 사용하도록 함
조인 전략에서 자식 테이블의 기본 값은 부모 테이블의 PK 컬럼명을 따르고 있다.
만약 자식 테이블의 컬럼명을 변경하고 싶다면 @PrimaryKeyJoinColumn을 이용해서 재 정의 해야한다.

@GeneratedValue : pk 생서 전략 설정
@Lob : BLOB,CLOB 타입 매핑
@Temporal : 날짜 타입 매핑
@Transient : 해당 필드는 매핑되지 않음
@Access : JPA 필드 접근 제한
AccessType.FIELD : 필드로 접근 private이어도 접근 가능
AccessType.PROPERTY : 접근자 Getter를 통해 접근
```

