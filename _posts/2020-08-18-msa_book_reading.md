---
# 포스트제목
title: "독후감 - 엔터프라이즈 자바 마이크로서비스 내용정리 "
# 포스팅 작성자
author: ["이동옥"] 
# 포스팅 공개일 - 정렬기준 포스팅날짜순서에 따라 기재됨.(주의 미래날짜는 기입X)
date: 2020-08-18 08:26:28 -0400
# 블로그 메인페이지에 썸네일과 함께 노출될 텍스트 설정 일정 길이를 초과하면 잘려서 표시됨.
# abstract:
# 태그를 입력
tags: ["MSA","마이크로서비스아키텍처","스프링클라우드"]
categories: JAVA
# 대표 이미지를 입력합니다. 이미지 업로드 위치는 아래에 기술합니다.
# image: /assets/images/posts/nerdfactory-documentation-history/main.jpg
# 포스트의 초안 여부를 입력합니다. "no" 로 입력할 경우 공개됩니다.
draft: "no"
toc: true
---
![gg](https://user-images.githubusercontent.com/12209348/100605351-26b6a580-334b-11eb-9785-7e1e5d79dbd0.PNG)

## msa를 공부하게 된 계기
요즘 다양한 플랫폼에서 클라우드 기반전략으로 시스템을 전향하고 있는추세였다. 내가근무했던 회사역시 클라우드화로 전향하기 시작했었고 클라우드 운영을 진행하는 과정에서 msa에 대한 관심이 생겼다.  
무턱대고 구글링을하면서 프로젝트를 진행하려했으나 기본이 탄탄하지 못하다는 생각이 들게 되면서 입문서를 통해 기초를 탄탄하게 쌓기위해 후기가 가장좋았던 입문서를 찾아 구매하게 되었다.   

## 책을 읽기전 중요단락  
책에서 주요내용으로 꼽는 4가지 큰 단락은 이와같다.  
 - 마이크로서비스 모델  
 - 클라우드 네이티브 개발  
 - 내고장성 전략과 모니터링 전략  
 - 개발을 마친 애플리케이션 보안 추가  
 
 - 엔터프라이즈 자바  
  API의 모음과 그 구현을 뜻함. -> UI부터 아랫단의 데이터베이스에이르기까지의 범위를 뜻함.  

## 모노리스 문제점  
 - 각컴포넌트의 규모 변경 불가  
 - 개별 컴포넌트의 성능 저하  
 - 개별 컴포넌트를 따로 전개 불가  
 - 코드 복잡도 증가  
 - 테스트 부정확도 증가  


## 정석 마이크로 서비스 아키텍처 구조
![11](https://user-images.githubusercontent.com/12209348/100836552-d78b8480-34b2-11eb-86f6-db4c323c51a4.PNG)

## 분산에 신경써야하는이유
 - 서비스 위치가 무관해짐  
 - 서비스가언어와 무관해짐  
 - 서비스전개규모가 작고 한가지 목적을 위해 전개됨.  
 - 새로운 서비스는 기존 서비스 기능을 재조합하는 방식  


## 마이크로서비스 문제점
- 서비스 독립성은 우수하지만 서비스간 서로연결하기는 어렵다.
  IP가아닌 논리적 네이밍을 가지고 서비스를 찾는다. 이를 서비스발견(서비스디스커버리라고함)
- 서비스 실패시 전체를 중단하지 않고 서비스 기능을 줄이면서 애플리케이션을 지속할 수단이필요하다.
  실패시 대안을제공하기위해 내고장성(폴트톨레런스)과 서비스탄력성(서비스 리슬라이스)이필요하다.
- 모노리스 운영 대비 < 마이크로서비스 운영의 부하가 더큼 
  그래서 이를 개선하기 위한 모니터링 자동화가 필요하다. 

마이크로서비스 개발은 개발난이도가 높음.

## 지속적인 통합, 지속적인 전달 (CI/CD)
 - 지속적인 통합(CI)
   소스 변경,커밋시 항상 새로 빌드되면서 관련된 테스트가 모두 수행된다는의미
   테스트가 충분하면 CI사용시 어떤 변경이 문제점인지 빠르게 인지할수 있음.
 - 지속적인 전달(CD)
   애플리케이션에 대한 변경이 지속적으로 프로덕션을 포함하는 여러 환경 사이에 전달되면서 
   변경한내용이 신속하게 고객에게 전달되도록 보장해주는것을 의미
   
## 모노리스에서 MSA전환시 사용되는 패턴
 - 도메인 주소 설계(DDD)
   기존의 프로세스에서 도메인모델 분리를 깔끔하게 해야하는데 이는 한계와 많은 어려움이 있다.
   그래서 소유자중심으로 구분하는데 이벤트소싱의 패턴을 사용하여 문제를해결해야한다.
  - 이벤트소싱 
   애플리케이션의 모든 상태 변경을을 이벤트로 발사하는기법 보통 이벤트들은 미리정해진 형태의 로그에 기록한다.
   이벤트를 저장한 로그를 사용해서 전체 데이터베이스를 재구축하거나 외부 도메인 모델 중 일부분을 전달할때 사용한다.
   
1. 빅뱅패턴
 - 가장난이도높은 패턴으로 기존 모노리스의 모든 부분을 하나하나 분리해서 마이크로 서비스로 변환하는 과정을 거친다.  
   마지막에 모노리스에서 마이크로 서비스로 모든 시스템이 전체적으로 이동한다.  
 - 전체적으로 모든 시스템을 전개해야하기 때문에 빅뱅이라는 이름과 함께 시간적 소요가 많이든다. 모노리스 구성만큼 소요됨.  
 - 대부분에서 빅뱅패턴은 권장하지 않음, 특히 MSA경험이없는 기업에서는 리스크가 너무 크기때문에 비추한다.  
 
2. 스트랭글러 패턴
 - 기존 서비스에서 하나씩 점진적으로 시스템을 구성하는 방식이다.
 - 기존 모노리스 환경을 유지하면서 MSA를 조금씩 늘려간다.
 - 장기적인 작업으로 빅뱅패턴보다 시간이 소요된다. 하지만 기존의 서비스에 대한 리스크는 훨씬 줄어든다.
 - 조금씩 구성하면서 상황을 모니터링하면서 문제는 조정하면서 안정화를 거듭해나갈수 있다.
 
3. 하이브리드 패턴
 - 저자의 의견은 가장 많이사용되는 패턴으로 꼽힌다고 한다.
 - 스트랭글러패턴과 비슷한 형태로 시작한다. 차이점은 모노리스를 없애지않는다는점이다.
 - 모노리스 안에 몇가지 기능을 유지하고 그 기능을 MSA에 통합하는방법이다. 
 
 * 사용자는 브라우저에서 자신이 보고 싶은 애플리케이션의 뷰를 요청한다.
 * 뷰는 자신을 만들어내기 위한 필요정보를 얻기 위해 컨트롤러를 호출한다.
 * 컨트롤러는 비즈니스 서비스를 호출한다. 컨트롤러는 여러 소스에서 얻은 데이터를 통합할수있다.
 * 게이트웨이는 미리 정의된 라우팅 규칙에 따라 요청을 적절한 MS에 전달한다.(MS 는 마이크로서비스라함.)
 * MS는 요청을 받고 자체처리를 진행한 후 다른 MS를 호출한다.
 * MS 사슬의 맨 마지막에 있는  MS는 데이터 저장소 계층과 상호작용해 레코드를 읽거나 쓸수있다.
 
### 하이브리드 아키텍처(이해를 위한 구성도)
![1](https://user-images.githubusercontent.com/12209348/101274031-0d47aa80-37de-11eb-8177-ca587b04f6a4.PNG)


### JeAS(just Enough Application Service) 꼭필요한 만큼의 애플리케이션 서버
 - MSA에서 사용할 수 있는 런타임 종류가 있음.
 
 - MSA에서는 다양한 환경이존재해 필요하지 않은 구성요소가 많아져 무거워질 수있어 JeAS를 사용한다.
 - 애플리케이션 서버의 구성 요소 중 애플리케이션 실행을 위해 필요한 부분만을 패키징한 것을 의미한다.


### 마이크로서비스 아키텍처의 런타임으로 JeAS사용하기
![44](https://user-images.githubusercontent.com/12209348/101485766-fdc38f80-399e-11eb-9dcb-1bdadec31da6.PNG)

### JeAS 장점  
 - 패키지 크기 감소  
 - 할당된 메모리 감소  
 - 보안 풋프린트 감소  
 - 애플리케이션 분리증대  
 - 업그레이드 단순화  
 
### 이클립스 마이크로프로파일  
 - 정의   
   마이크로서비스를 위해 엔터프라이즈 자바를 최적화 하기위해 (레드헷,IBM, 등 자바 커뮤니티진들이협력하여만든 것)  
   
 -  마이크로프로파일은 엔터프라이즈 자바 마이크로서비스를 ㅁ위한 명세를 만들고 JeAS런타임은 프로파일과 서로 호환되는 장점이있음.  
 
 
### 드롭위자드
정의 : MSA위해 개발자에게 필요한 내용을 선택가능하게 함으로 JeAS 런타임을 제공
이클립스제티, Jersey, Jackson, 하이버네이트 벨리데이터, 모니터링용 드룹위자드 지표


### 스프링부트-> 옵션화한 스프링 마이크로서비스
다양한 스타터를 제공하여 빠르게 시스템을 구성할 수있도록 구성되어있음.




기존 유형과 다른 컨트롤러 구조

```
@RestController
public class CartController
  @RequestMapping(
    method= RequestMethod.GET, // Http GET 요청의 `/`URL 경로를 통해 이메서드를 사용한다.
    path="/",
    produces = "application/json")
  public List<CartItem> all() throws Exception {} 
  
   @RequestMapping(
    method= RequestMethod.GET, 
    path="/add",
    produces = "application/json")
  public String addOrUpdateItem(
    @RequestParam("Item") String itemName, // item이라는 이름의 URL 질의 파라미터가 이 메서드 파라미터에 매핑된다.
    @RequestParam("qty") Integer qty) throws Exception{
    }
  
  @RequestMapping(
    method= RequestMethod.GET, 
    path="/get/{itemName}",   // 이 종단점에 대한 URL 결로 변수가 /get/ 뒤에온다.
    produces = "application/json")
  public CartItem getItem(
     @PathVariavle("itemName") String itemName) throws Exception{ // URL 경로 변수가 메서드 파라미터에 맵핑된다.
     }
```

위와 같이 @GET, @Produces, @Path 등의 정보를 한꺼번에 지정한다.  다른차이점은 @QueryParam, @PathParam 대신 
@RequestParam, @PathVariable을 사용한다는 것이다.

### 손테일
JAX-RS, JMS, CDI 마이크로서비스에서 꼭 필요한 항목을 집중시킨 기능이며  
https://thorntail.io/generator/   
에서 기능을 제공한다.  

#### 손테일 플러그인 설정
```
   <plugin>
     <groupId>io.thorntail</groupId>
     <artifactId>thorntail-maven-plugin</artifactId>
     <version2.2.0</version>
     <executions>
      <execution>
       <goals>
         <goal>package</goal>
       </goals>
      </execution>
      </executions>
   </plugin>
```

```
// 스코프 안에 Java EE 웹 API를 추가한다.
<dependency>
   <groupId>javax</groupId>
   <artifactId> javaee-web-api</artifactId>
   <version>7.0</version>
   <scope>provided</scope>
</dependency>

```

```
//손테일을 사용하는 JaxrsApplication
@ApplicationPath("/")
public class JaxrsApplication extends Application{

}
```


### JeAS를 채택하기 위한 고려사항
 1. 기업이나 개발자가 JavaEE나 스프링에 대한 경험, 지식이있는가
 2. 프로덕션에서 가장 선호하는 패키징 방식이 무엇인가
 3. 해당 프레임워크의 JeAS가 아닌 런타임을 사용해본 경험이 있는가?
 
### JeAS 관련 
- JeAS를 사용하면 마이크로서비스와 함께 사용하기에 꼭 필요한 런타임만을 패키징할수있다.
이는 손테일이 ㄷ가장 커스텀화를 잘할수 있는 JeAS 런타임이다.
- JeAS 런타임을 사용하면서 필요한 부분만선택하면 엔터프라이즈 자바 애플리케이션 서버에서 필요한 부분만 골라 사용할 수 있다.
- JeAS 런타임은 RESTful 마이크로서비스를 전개할 때 최고의 전개 방법이다.
- 마이크로프로파일은 클라우드 네이티브 마이크로서비스 개발에 필요한 특징을 제공한다.


## MSA TEST
적합한 유형의 Unit TEST
1. 단위테스트
2. 통합 테스트
3. 소비자 중심 계약 테스트
  
단위테스트와 통합테스트는 기존의 테스트 개념과 다르지 않다.   
MSA를 튼튼하게 구성하기 위해서는 위의 3가지 테스트방법이 필수적이다.  
단위 테스트와 통합 테스트는 MSA를 개발하면서 작성한 코드가 MSA를 기술하는 명세에 들어맞는지 확인하는 데 초점을 둔 것이다.   
소비자 중심 계약 테스트는 MSA 외부에서 살펴보는 관점으로 클라이언트가 MSA에 넘기는 요청을 제대로 처리하는지 확인하는목적으로 사용된다.  

테스트 목적  
테스트의목적은 단발성이 아닌 계속적으로 변경되는 코드에 테스트하기 위한 것이며, 코드를 정기적으로 빌드하는 지속적인 통합 과정의 일환으로 테스트가 진행되야한다. 
테스트가 프로덕션까지 도달할 수 있는 오류나 버그의 수를 줄여주는 이점이 있다.

MSA 3가지 테스트 목적 구성
![44](https://user-images.githubusercontent.com/12209348/103437499-bbbefe00-4c6b-11eb-9150-63b320418a5f.PNG)

### 단위테스트
 - 클래스와 클래스에 있는 메서드의 내부 동작을 테스트한다.
 - 개발시 단위 테스트를 위해 목 또는 스텁이 필요한 경우도 있다. 목이나 스텁은 클래스나 메서드를 테스트하기 위해 필요한 외부 시스템의 동작을 흉내낸다.

단위테스트 필요이유  
 1. 클래스 내부 메서드가 의도대로 작동하는지 확인해야한다. 
 2. 검증은 null 체크부터 전자우편 주소가 올바른지 체크하는 복잡한 경우까지 다양하다.
  사용되는 프레임워크는 JUNIT, TestNG다. 
  
  이중 나는 JUNIT을 사용할것이며
  책에서 제공하는 데모 chapter4/admin 소스를 실습할 것이다.
  
불변성
객체지향에서 불변성이란 객체 상태를 변경할 수 있는지를 알려주는 개념이다. 객체 생성 뒤 그 상태를 바꿀 수 없는 경우 그 객체는 변경 불가능하다.

////////소스코드 넣어서 정리해야됨


### 통합테스트
통합테스트는 외부 시스템과 마이크로서비스의 상호작용을 테스트한다.  
이런 외부 시스템에는 데이터베이스, 메시징 시스템, 다른 마이크로서비스, 우리 마이크로서비스 내부 코드는 아니지만 통신할 필요가 있는 다른 대부분의 시스템을 포함한다.  
단위테스트에서 이런 외부시스템에대한 mock이나 stub을 사용하는 경우 통합 테스트에서는 mock과 stub을 실제 외부 테스트에 대한호출로 바꾼다. 
mock과 stub을 제거하면 코드가 이전에 테스트하지 못했던 실행경로를 따라 실행 될 수도있고 외부 시스템의 오류를 처리하는 부분에 대한 테스트 시나리오를 추가해야할 수도 있다.

마이크로서비스와 통합시킬 시스템의 유형에 따라서는 로컬 개발자 컴퓨터만으로 테스트하지 못할수 있다. 통합테스트 경우 자원이 풍부하고 필요한 시스템을 원하는 대로 설치할수있는 지속적인 개선이 이뤄지는 환경에 적합하다.


통합테스트에 개발을 돕기 위해 아퀼리안을 사용할것이다.  

아퀼리안이란?  
JVM에서 실행 가능한 확장성 좋은 테스트 플랫폼이며, 통합, 기능, 인수 테스트를 쉽게 구성할수있음.


통합 테스트 도구로 아퀼리안은 프로덕션 환경을 구축하지 않고도 프로덕션 환경에 가까운 복제품을 제공할 수있기때문이다.(아퀼리안 알아볼것)

 - 메이븐 디펜던시 추가할것 (아퀼리안)

첫째. 의존관계는 아퀼리안 테스트에서 손테일이 사용할 런타임 컨테이너를 추가한다.
두째. 의존관계는 아퀼리안과 JUnit을 통합시켜준다. 런타임 컨테이너에 접근해야한다.
셋째. 손테일의 아퀼리안 의존관계는 손테일 자신을 아퀼리안과 함께 런타임 컨테이너로 등록해서 아퀼리안이 자신을 손테일에게 전개할 수 있게 한다.







### 소비자 중심 계약테스트




#### 테스트 장 요약  
 - 단위 테스트는 중요하지만 단위 테스트 말고도 필요한 테스트가 많다. 서비스의 모든 측면을 가능한 실제와 비슷한 환경에서 테스트해야한다.  
 - 아퀼리안은 프로덕션 환경에 가까운 환경을 제공하고 그런 환경과 상호작용해야하는 런타임 컨테이너가 필요한 테스트를 단순화할 수 있는 훌륭한 테스트 프레임워크이다.(꼭 조사할것)  
 - MSA TEST의 핵심은 MSA가 정의하는 계약, MSA가 노출하는 API를 검증하되 MSA가 API를 노출하는 의도에 대해서가 아닌 클라이언트가 어떤 요청을 보내고 어떤 응답을 받을 것으로 예상하는지 검증하는 것이다.
 
 테스트장 코딩해볼것 
 
 
## 클라우드 네이티브 개발
### 클라우드 장점
 - 비용효율성
 대부분 클라우드는 기업이 사용한 CPU시간만큼 비용을 부과한다. 이로인해 물리적으로 서버를 사용하는 경우에비해서 컴퓨팅 환경을 운영하는비용이줄어든다.
 - 규모변경성
 필요에 따라 스케일업, 스케일다운을 할 수 있도록 기능을 제공한다. 트래픽의 따라 유동적으로 대처할 수 있다. 기존 인스턴스를 복제해서 메모리, CPU 등 동일설정의 새인스턴스를 제공함으로 빠르게 확장할 수있는 점이 있다.
 - 선택의자유
운영팀이 아는 관리환경이라고는 자바뿐인 기업에서 오직 자바 개발만 한 개발자라면 어떻게 노드 JS나 고와 같은 새로운 프로그래밍 언어로 개발해볼수 있겠는가? 클라우드는 이전과 달리 마우스 클릭 몇번만에 새로운 런타임 환경을 제공한다. 그런 새언어 환경을 유지보수하기 위한 내부경험도 필요없다. 클라우드 제공업체가 신경써야하는 부분이다.


### 서비스 모델
클라우드에서 사용할 수 있는 다양한 




![22](https://user-images.githubusercontent.com/12209348/104115874-5a77e880-5357-11eb-899f-508aa58dd3d0.PNG)
