---
# 포스트제목
title: "독후감 - 엔터프라이즈 자바 마이크로서비스 내용정리 "
# 포스팅 작성자
author: ["이동옥"] 
# 포스팅 공개일 - 정렬기준 포스팅날짜순서에 따라 기재됨.(주의 미래날짜는 기입X)
date: 2020-08-18 08:26:28 -0400
# 블로그 메인페이지에 썸네일과 함께 노출될 텍스트 설정 일정 길이를 초과하면 잘려서 표시됨.
# abstract:
# 태그를 입력
tags: ["MSA","마이크로서비스아키텍처","스프링클라우드"]
categories: JAVA
# 대표 이미지를 입력합니다. 이미지 업로드 위치는 아래에 기술합니다.
# image: /assets/images/posts/nerdfactory-documentation-history/main.jpg
# 포스트의 초안 여부를 입력합니다. "no" 로 입력할 경우 공개됩니다.
draft: "no"
toc: true
---
![gg](https://user-images.githubusercontent.com/12209348/100605351-26b6a580-334b-11eb-9785-7e1e5d79dbd0.PNG)

## msa를 공부하게 된 계기
요즘 다양한 플랫폼에서 클라우드 기반전략으로 시스템을 전향하고 있는추세였다. 내가근무했던 회사역시 클라우드화로 전향하기 시작했었고 클라우드 운영을 진행하는 과정에서 msa에 대한 관심이 생겼다.  
무턱대고 구글링을하면서 프로젝트를 진행하려했으나 기본이 탄탄하지 못하다는 생각이 들게 되면서 입문서를 통해 기초를 탄탄하게 쌓기위해 후기가 가장좋았던 입문서를 찾아 구매하게 되었다.   

## 책을 읽기전 중요단락  
책에서 주요내용으로 꼽는 4가지 큰 단락은 이와같다.  
 - 마이크로서비스 모델  
 - 클라우드 네이티브 개발  
 - 내고장성 전략과 모니터링 전략  
 - 개발을 마친 애플리케이션 보안 추가  
 
 - 엔터프라이즈 자바  
  API의 모음과 그 구현을 뜻함. -> UI부터 아랫단의 데이터베이스에이르기까지의 범위를 뜻함.  

## 모노리스 문제점  
 - 각컴포넌트의 규모 변경 불가  
 - 개별 컴포넌트의 성능 저하  
 - 개별 컴포넌트를 따로 전개 불가  
 - 코드 복잡도 증가  
 - 테스트 부정확도 증가  


## 정석 마이크로 서비스 아키텍처 구조
![11](https://user-images.githubusercontent.com/12209348/100836552-d78b8480-34b2-11eb-86f6-db4c323c51a4.PNG)

## 분산에 신경써야하는이유
 - 서비스 위치가 무관해짐  
 - 서비스가언어와 무관해짐  
 - 서비스전개규모가 작고 한가지 목적을 위해 전개됨.  
 - 새로운 서비스는 기존 서비스 기능을 재조합하는 방식  


## 마이크로서비스 문제점
- 서비스 독립성은 우수하지만 서비스간 서로연결하기는 어렵다.
  IP가아닌 논리적 네이밍을 가지고 서비스를 찾는다. 이를 서비스발견(서비스디스커버리라고함)
- 서비스 실패시 전체를 중단하지 않고 서비스 기능을 줄이면서 애플리케이션을 지속할 수단이필요하다.
  실패시 대안을제공하기위해 내고장성(폴트톨레런스)과 서비스탄력성(서비스 리슬라이스)이필요하다.
- 모노리스 운영 대비 < 마이크로서비스 운영의 부하가 더큼 
  그래서 이를 개선하기 위한 모니터링 자동화가 필요하다. 

마이크로서비스 개발은 개발난이도가 높음.

## 지속적인 통합, 지속적인 전달 (CI/CD)
 - 지속적인 통합(CI)
   소스 변경,커밋시 항상 새로 빌드되면서 관련된 테스트가 모두 수행된다는의미
   테스트가 충분하면 CI사용시 어떤 변경이 문제점인지 빠르게 인지할수 있음.
 - 지속적인 전달(CD)
   애플리케이션에 대한 변경이 지속적으로 프로덕션을 포함하는 여러 환경 사이에 전달되면서 
   변경한내용이 신속하게 고객에게 전달되도록 보장해주는것을 의미
   
## 모노리스에서 MSA전환시 사용되는 패턴
 - 도메인 주소 설계(DDD)
   기존의 프로세스에서 도메인모델 분리를 깔끔하게 해야하는데 이는 한계와 많은 어려움이 있다.
   그래서 소유자중심으로 구분하는데 이벤트소싱의 패턴을 사용하여 문제를해결해야한다.
  - 이벤트소싱 
   애플리케이션의 모든 상태 변경을을 이벤트로 발사하는기법 보통 이벤트들은 미리정해진 형태의 로그에 기록한다.
   이벤트를 저장한 로그를 사용해서 전체 데이터베이스를 재구축하거나 외부 도메인 모델 중 일부분을 전달할때 사용한다.
   
1. 빅뱅패턴
 - 가장난이도높은 패턴으로 기존 모노리스의 모든 부분을 하나하나 분리해서 마이크로 서비스로 변환하는 과정을 거친다.  
   마지막에 모노리스에서 마이크로 서비스로 모든 시스템이 전체적으로 이동한다.  
 - 전체적으로 모든 시스템을 전개해야하기 때문에 빅뱅이라는 이름과 함께 시간적 소요가 많이든다. 모노리스 구성만큼 소요됨.  
 - 대부분에서 빅뱅패턴은 권장하지 않음, 특히 MSA경험이없는 기업에서는 리스크가 너무 크기때문에 비추한다.  
 
2. 스트랭글러 패턴
 - 기존 서비스에서 하나씩 점진적으로 시스템을 구성하는 방식이다.
 - 기존 모노리스 환경을 유지하면서 MSA를 조금씩 늘려간다.
 - 장기적인 작업으로 빅뱅패턴보다 시간이 소요된다. 하지만 기존의 서비스에 대한 리스크는 훨씬 줄어든다.
 - 조금씩 구성하면서 상황을 모니터링하면서 문제는 조정하면서 안정화를 거듭해나갈수 있다.
 
3. 하이브리드 패턴
 - 저자의 의견은 가장 많이사용되는 패턴으로 꼽힌다고 한다.
 - 스트랭글러패턴과 비슷한 형태로 시작한다. 차이점은 모노리스를 없애지않는다는점이다.
 - 모노리스 안에 몇가지 기능을 유지하고 그 기능을 MSA에 통합하는방법이다. 
 
 * 사용자는 브라우저에서 자신이 보고 싶은 애플리케이션의 뷰를 요청한다.
 * 뷰는 자신을 만들어내기 위한 필요정보를 얻기 위해 컨트롤러를 호출한다.
 * 컨트롤러는 비즈니스 서비스를 호출한다. 컨트롤러는 여러 소스에서 얻은 데이터를 통합할수있다.
 * 게이트웨이는 미리 정의된 라우팅 규칙에 따라 요청을 적절한 MS에 전달한다.(MS 는 마이크로서비스라함.)
 * MS는 요청을 받고 자체처리를 진행한 후 다른 MS를 호출한다.
 * MS 사슬의 맨 마지막에 있는  MS는 데이터 저장소 계층과 상호작용해 레코드를 읽거나 쓸수있다.
 
### 하이브리드 아키텍처(이해를 위한 구성도)
![1](https://user-images.githubusercontent.com/12209348/101274031-0d47aa80-37de-11eb-8177-ca587b04f6a4.PNG)


### JeAS(just Enough Application Service) 꼭필요한 만큼의 애플리케이션 서버
 - MSA에서 사용할 수 있는 런타임 종류가 있음.
 
 - MSA에서는 다양한 환경이존재해 필요하지 않은 구성요소가 많아져 무거워질 수있어 JeAS를 사용한다.
 - 애플리케이션 서버의 구성 요소 중 애플리케이션 실행을 위해 필요한 부분만을 패키징한 것을 의미한다.


### 마이크로서비스 아키텍처의 런타임으로 JeAS사용하기
![44](https://user-images.githubusercontent.com/12209348/101485766-fdc38f80-399e-11eb-9dcb-1bdadec31da6.PNG)

### JeAS 장점  
 - 패키지 크기 감소  
 - 할당된 메모리 감소  
 - 보안 풋프린트 감소  
 - 애플리케이션 분리증대  
 - 업그레이드 단순화  
 
### 이클립스 마이크로프로파일  
 - 정의   
   마이크로서비스를 위해 엔터프라이즈 자바를 최적화 하기위해 (레드헷,IBM, 등 자바 커뮤니티진들이협력하여만든 것)  
   
 -  마이크로프로파일은 엔터프라이즈 자바 마이크로서비스를 ㅁ위한 명세를 만들고 JeAS런타임은 프로파일과 서로 호환되는 장점이있음.  
 
 
### 드롭위자드
정의 : MSA위해 개발자에게 필요한 내용을 선택가능하게 함으로 JeAS 런타임을 제공
이클립스제티, Jersey, Jackson, 하이버네이트 벨리데이터, 모니터링용 드룹위자드 지표


### 스프링부트-> 옵션화한 스프링 마이크로서비스
다양한 스타터를 제공하여 빠르게 시스템을 구성할 수있도록 구성되어있음.




기존 유형과 다른 컨트롤러 구조

```
@RestController
public class CartController
  @RequestMapping(
    method= RequestMethod.GET, // Http GET 요청의 `/`URL 경로를 통해 이메서드를 사용한다.
    path="/",
    produces = "application/json")
  public List<CartItem> all() throws Exception {} 
  
   @RequestMapping(
    method= RequestMethod.GET, 
    path="/add",
    produces = "application/json")
  public String addOrUpdateItem(
    @RequestParam("Item") String itemName, // item이라는 이름의 URL 질의 파라미터가 이 메서드 파라미터에 매핑된다.
    @RequestParam("qty") Integer qty) throws Exception{
    }
  
  @RequestMapping(
    method= RequestMethod.GET, 
    path="/get/{itemName}",   // 이 종단점에 대한 URL 결로 변수가 /get/ 뒤에온다.
    produces = "application/json")
  public CartItem getItem(
     @PathVariavle("itemName") String itemName) throws Exception{ // URL 경로 변수가 메서드 파라미터에 맵핑된다.
     }
```

위와 같이 @GET, @Produces, @Path 등의 정보를 한꺼번에 지정한다.  다른차이점은 @QueryParam, @PathParam 대신 
@RequestParam, @PathVariable을 사용한다는 것이다.

### 손테일
JAX-RS, JMS, CDI 마이크로서비스에서 꼭 필요한 항목을 집중시킨 기능이며  
https://thorntail.io/generator/   
에서 기능을 제공한다.  

#### 손테일 플러그인 설정
```
   <plugin>
     <groupId>io.thorntail</groupId>
     <artifactId>thorntail-maven-plugin</artifactId>
     <version2.2.0</version>
     <executions>
      <execution>
       <goals>
         <goal>package</goal>
       </goals>
      </execution>
      </executions>
   </plugin>
```

```
// 스코프 안에 Java EE 웹 API를 추가한다.
<dependency>
   <groupId>javax</groupId>
   <artifactId> javaee-web-api</artifactId>
   <version>7.0</version>
   <scope>provided</scope>
</dependency>

```

```
//손테일을 사용하는 JaxrsApplication
@ApplicationPath("/")
public class JaxrsApplication extends Application{

}
```


### JeAS를 채택하기 위한 고려사항
 1. 기업이나 개발자가 JavaEE나 스프링에 대한 경험, 지식이있는가
 2. 프로덕션에서 가장 선호하는 패키징 방식이 무엇인가
 3. 해당 프레임워크의 JeAS가 아닌 런타임을 사용해본 경험이 있는가?
 
### JeAS 관련 
- JeAS를 사용하면 마이크로서비스와 함께 사용하기에 꼭 필요한 런타임만을 패키징할수있다.
이는 손테일이 ㄷ가장 커스텀화를 잘할수 있는 JeAS 런타임이다.
- JeAS 런타임을 사용하면서 필요한 부분만선택하면 엔터프라이즈 자바 애플리케이션 서버에서 필요한 부분만 골라 사용할 수 있다.
- JeAS 런타임은 RESTful 마이크로서비스를 전개할 때 최고의 전개 방법이다.
- 마이크로프로파일은 클라우드 네이티브 마이크로서비스 개발에 필요한 특징을 제공한다.


## MSA TEST
적합한 유형의 Unit TEST
1. 단위테스트
2. 통합 테스트
3. 소비자 중심 계약 테스트
  
단위테스트와 통합테스트는 기존의 테스트 개념과 다르지 않다.   
MSA를 튼튼하게 구성하기 위해서는 위의 3가지 테스트방법이 필수적이다.  
단위 테스트와 통합 테스트는 MSA를 개발하면서 작성한 코드가 MSA를 기술하는 명세에 들어맞는지 확인하는 데 초점을 둔 것이다.   
소비자 중심 계약 테스트는 MSA 외부에서 살펴보는 관점으로 클라이언트가 MSA에 넘기는 요청을 제대로 처리하는지 확인하는목적으로 사용된다.  

테스트 목적  
테스트의목적은 단발성이 아닌 계속적으로 변경되는 코드에 테스트하기 위한 것이며, 코드를 정기적으로 빌드하는 지속적인 통합 과정의 일환으로 테스트가 진행되야한다. 
테스트가 프로덕션까지 도달할 수 있는 오류나 버그의 수를 줄여주는 이점이 있다.

MSA 3가지 테스트 목적 구성
![44](https://user-images.githubusercontent.com/12209348/103437499-bbbefe00-4c6b-11eb-9150-63b320418a5f.PNG)

### 단위테스트
 - 클래스와 클래스에 있는 메서드의 내부 동작을 테스트한다.
 - 개발시 단위 테스트를 위해 목 또는 스텁이 필요한 경우도 있다. 목이나 스텁은 클래스나 메서드를 테스트하기 위해 필요한 외부 시스템의 동작을 흉내낸다.

단위테스트 필요이유  
 1. 클래스 내부 메서드가 의도대로 작동하는지 확인해야한다. 
 2. 검증은 null 체크부터 전자우편 주소가 올바른지 체크하는 복잡한 경우까지 다양하다.
  사용되는 프레임워크는 JUNIT, TestNG다. 
  
  이중 나는 JUNIT을 사용할것이며
  책에서 제공하는 데모 chapter4/admin 소스를 실습할 것이다.
  
불변성
객체지향에서 불변성이란 객체 상태를 변경할 수 있는지를 알려주는 개념이다. 객체 생성 뒤 그 상태를 바꿀 수 없는 경우 그 객체는 변경 불가능하다.

////////소스코드 넣어서 정리해야됨


### 통합테스트
통합테스트는 외부 시스템과 마이크로서비스의 상호작용을 테스트한다.  
이런 외부 시스템에는 데이터베이스, 메시징 시스템, 다른 마이크로서비스, 우리 마이크로서비스 내부 코드는 아니지만 통신할 필요가 있는 다른 대부분의 시스템을 포함한다.  
단위테스트에서 이런 외부시스템에대한 mock이나 stub을 사용하는 경우 통합 테스트에서는 mock과 stub을 실제 외부 테스트에 대한호출로 바꾼다. 
mock과 stub을 제거하면 코드가 이전에 테스트하지 못했던 실행경로를 따라 실행 될 수도있고 외부 시스템의 오류를 처리하는 부분에 대한 테스트 시나리오를 추가해야할 수도 있다.

마이크로서비스와 통합시킬 시스템의 유형에 따라서는 로컬 개발자 컴퓨터만으로 테스트하지 못할수 있다. 통합테스트 경우 자원이 풍부하고 필요한 시스템을 원하는 대로 설치할수있는 지속적인 개선이 이뤄지는 환경에 적합하다.


통합테스트에 개발을 돕기 위해 아퀼리안을 사용할것이다.  

아퀼리안이란?  
JVM에서 실행 가능한 확장성 좋은 테스트 플랫폼이며, 통합, 기능, 인수 테스트를 쉽게 구성할수있음.


통합 테스트 도구로 아퀼리안은 프로덕션 환경을 구축하지 않고도 프로덕션 환경에 가까운 복제품을 제공할 수있기때문이다.(아퀼리안 알아볼것)

 - 메이븐 디펜던시 추가할것 (아퀼리안)

첫째. 의존관계는 아퀼리안 테스트에서 손테일이 사용할 런타임 컨테이너를 추가한다.
두째. 의존관계는 아퀼리안과 JUnit을 통합시켜준다. 런타임 컨테이너에 접근해야한다.
셋째. 손테일의 아퀼리안 의존관계는 손테일 자신을 아퀼리안과 함께 런타임 컨테이너로 등록해서 아퀼리안이 자신을 손테일에게 전개할 수 있게 한다.







### 소비자 중심 계약테스트




#### 테스트 장 요약  
 - 단위 테스트는 중요하지만 단위 테스트 말고도 필요한 테스트가 많다. 서비스의 모든 측면을 가능한 실제와 비슷한 환경에서 테스트해야한다.  
 - 아퀼리안은 프로덕션 환경에 가까운 환경을 제공하고 그런 환경과 상호작용해야하는 런타임 컨테이너가 필요한 테스트를 단순화할 수 있는 훌륭한 테스트 프레임워크이다.(꼭 조사할것)  
 - MSA TEST의 핵심은 MSA가 정의하는 계약, MSA가 노출하는 API를 검증하되 MSA가 API를 노출하는 의도에 대해서가 아닌 클라이언트가 어떤 요청을 보내고 어떤 응답을 받을 것으로 예상하는지 검증하는 것이다.
 
 테스트장 코딩해볼것 
 
 
## 클라우드 네이티브 개발
### 클라우드 장점
 - 비용효율성
 대부분 클라우드는 기업이 사용한 CPU시간만큼 비용을 부과한다. 이로인해 물리적으로 서버를 사용하는 경우에비해서 컴퓨팅 환경을 운영하는비용이줄어든다.
 - 규모변경성
 필요에 따라 스케일업, 스케일다운을 할 수 있도록 기능을 제공한다. 트래픽의 따라 유동적으로 대처할 수 있다. 기존 인스턴스를 복제해서 메모리, CPU 등 동일설정의 새인스턴스를 제공함으로 빠르게 확장할 수있는 점이 있다.
 - 선택의자유
운영팀이 아는 관리환경이라고는 자바뿐인 기업에서 오직 자바 개발만 한 개발자라면 어떻게 노드 JS나 고와 같은 새로운 프로그래밍 언어로 개발해볼수 있겠는가? 클라우드는 이전과 달리 마우스 클릭 몇번만에 새로운 런타임 환경을 제공한다. 그런 새언어 환경을 유지보수하기 위한 내부경험도 필요없다. 클라우드 제공업체가 신경써야하는 부분이다.


### 서비스 모델
클라우드에서 사용할 수 있는 다양한 서비스 모델을 보여주고 애플리케이션이 어떤 위치에 들어가는지 보여준다. 애플리케이션은 서버상에 있는 코드다. 애플리케이션이 온전한 모바일 기기나 브라우저에서 실행되면서 SaaS로 있는 여러 서비스와 상호작용한다면, 그 또한 애플리케이션이 맞지만 이 그림에 표현한 애플리케이션과는 다른종류의 애플리케이션이다. (JAR,WAR,EAR을 뜻함)


![22](https://user-images.githubusercontent.com/12209348/104115874-5a77e880-5357-11eb-899f-508aa58dd3d0.PNG)
### 클라우드 서비스 각 계층  
 - Infra as a Service(Iaas, 인프라 제공 서비스)  
 컴퓨팅 자원, 데이터 파티셔닝, 규모확장, 보안, 백업 등 포함하는 네트워크 인프라에 대한 추상화된 서비스  
 보통 가상 머신을 게스트로 실행할 수 있는 하이퍼바이저를 포함한다.IaaS를 사용하기 위해서그 환경에 맞는 가상머신을 개발자가 직접 구성해야한다.
 - Platform as a Service(Paas, 플랫폼 제공 서비스)  
 Iaas위에서 운영체제, 다양한 프로그래밍 언어에 대한 실행환경, 데이터베이스, 웹 서버를 제공하는 계층이다.  
 개발자가 애플리케이션 개발을 위한 하드웨어와 스프트웨어를 구매하고 설치하지 않았도 된다.  
 - Software as a Service(Saas, 소프트웨어 제공 서비스)  
 애플리케이션의 일부분이나 전체 애플리케이션을 사용자의 필요나 요청에 따라 제공한다. 보통 종량제로 과금된다.  
 마케팅 같은 틈새 시장에 해당하는 서비스 부터 비즈니스를 처음부터 끝까지 관리할 수 있는 서비스까지 다양하다.  
 - Container as a Service(CaaS, 컨테이너 제공 서비스) -> 관련키워드 도커  
 Paas의 하부구조, 도커와 같은 컨테이너 기술을 활용해서 전개, 규모확장이나 축소, 다양한 ㅇ애플리케이션이나 서비스에 대한관리를 단순화시켜줌.
 가장대중화 된건 쿠버네티스
 컨테이너가 변경 불가능하다. 컨테이너 내부를 변경하면 새로운 버전의 컨테이너 이미지가 만들어져야한다. 프로덕션에 릴리스 하기 전에 원하는대로 컨테이너가 동작하는지 검증할 수 있는장점이있다.
 쿠버네티스는 컨테이너에 넣은 애플리케이션을 관리하는 방법에서 많은영향을 받음.


#### 클라우드 네이티브 개발
클라우드 환경에서 전개할 것을 전재로 서비스나 애플리케이션을 개발하는 것을 뜻함. 서비스나 애플리케이션은 서로 느슨하게 연결되어있는 클라우드 서비스의 이점을 


애플리케이션이나 서비스가 제대로 작동하기 위해 필요한 것 중 상당 부분을

쿠버네티스는 서비스카탈로그 개념을 가졌음. 대부분 


#### 클라우드전개
private 사설 클라우드
특정기업만 사용가능한 클라우드로 보통 기업내부용 으로활용

public 공용 클라우드
클라우드 안에 있는 서비스를 대중이사용할수 있는 네트워크를 통해 구성 MSA나 데이터베이스 모두 퍼블릭에있을경우 강력한 보안이 뒷받침되야한다.

hybrid 하이브리드 클라우드
사설 클라우드와 공용 클라우드를 조합한 클라우드로 서로 다른 업체가 제공하는 사성과 공용클라우드를 사용할 수 있다. 하이브리드 클라우드는 빠른 속도로 가장 일반적인 전개모델이 되고 있다.
사성과 공용 양 전개 모델의 장점만 제공되기 때문이다. 빠르게 용량과 규모 보안까지 챙기고 싶다면 이를 선택하면 된다.

### 미니시프트
로컬컴퓨터에서 실행되는 사설 클라우드 인스턴스를 제공한다. 하지만 미니시프트에 있는 PaaS인 오픈시프트는 하이브리드 클라우드나 공용클라우드에서 사용하는 오픈시프트와 동일한 PaaS다. 다른점은 미니시프트 쪽의 PaaS가 로컬 컴퓨터에서 실행된다는 점이다.

```
//터미널에서 설치 스펙할당은 2개의 가상머신, CPU, 2GB RAM, 20GB Hdd 할당해준다.
minishift start
// 설치완료, 로그인 후 
minishift console
//명령으로 콘솔화면을 웹으로 띄운다.
```
미니시프트는 시작하면서 어떤일을 진행하고 있는지 터미널에 자세히 표시한다.


요약
 - Caas를 내부에서 사용하는  Paas를 선택하면 변경 불가능한 컨테이너 이미지의 장점을 누릴 수 있다.
 - 미니시프트는 로컬 컴퓨터에서 오픈시프트를 사용하는 클라우드 환경을 제공한다. 따라서 여러 기계를 관리할 필요 없이 마이크로서비스를 실행하고 테스트하는과정을 단순화 할 수 있다.
 - fabric8메이븐 플러그인은 오픈시프트나 쿠버네티스에서 자원과 서비스를 정의할 때 필요한 성가신 준비 과정을 모두 없애준다. 그래서 fabrics8은 클라우드에서 마이크로서비스가 실행되는 모습을 보기 위해 필요한 설정의 어려움을 잘 넘길 수 있게 해준다.
 
 
 
## 엔터프라이즈 자바  마이크로서비스 구현(심화)
 - EJB를 사용하는 @EJB 주입
 - CDI를 사용한 @Inject
 - static 메서드나 변수를 통해서비스 인스턴스 가져오기
 - XML이나 애노테이션을 기반으로 하는 스프링 의존관계 주입(DI)



다른 서비스와 포트 번호가 겹치는 일이 없도록 CategoryResource의 포트를 지정할 수 있다. 메이븐에서 swarm.port.offset 프로퍼티를  | 로 설정하라.
```
//Category 모델 클래스
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id") //카테고리 ID를 키로 정의, JSON으로 받은 자식 컬렉션을 역직렬화할 때 사용함
public class Category{
 protected Integer id;
 protected String name;
 protected String header;
 protected LocalDateTime created = LocalDateTime.new(); //자식 컬렉션을 빈 객체로 초기화해서 자식이 없는 경우에도 올바른 컬렉션을 반환하도록 함
 protected LocalDateTime updated;
 protected Integer version;
 ...
}
```

추가로 각 서비스에게는 새로운 스레드에서 수행할 작업을 제출하기 위한 Executor Service가 필요하다. 모든 서비스들이 같은 방식으로 작업을 수행하도록 Java EE가 제공하는 ExecutorService를 사용한다.

```
private ManagedExecutorService executorService() throws Exception{
  InitalContext ctx = new InitialContext();
  return(ManagedExecutorService)
      ctx.lookup("java:jboss/ee/concurrency/executor/default");
}

```
이 코드는 서비스이름을 가지고 간단한 JNDI 검색을 수행해서 여러분이 작업을 제출할 수 없는 실행기 서비스의 인스턴스를 찾아 반환한다.
Tip. 여기서 사용하는 ExecutorService는 와일드 플라이에 정의된 것이다. 따라서 이를 JNDI에서 가져오기 위해 무언가를 별도로 설정할 필요가 없다.
여러분의 서비스가 필요한 작업을 수행하기 위해 새 Thread를 직접 만들 수도 있지만, 그렇게 만든 스레드는 JAVA EE가 관리하는 스레드풀 밖에 있게된다. 그게 문제가 될 수 있을까? 항상 그렇지는 않다. 
결과를 동기식, 비동기식으로 처리하느냐에 따라 마이크로 서비스를 소비하는 클라이언트 두가지 종단점을 제공한다.



## 소비할 마이크로서비스 발견하기

주요내용
- 서비스 발견이 중요한 이유
- 클라이언트가 찾을 수 있게 마이크로서비스를 등록하는 방법
- 손테일이 지원하는 서비스 레지스트리 종류
- 클라이언트가 마이크로서비스를 찾아내는 방법


왜 마이크로서비스를 발견할 수 있어야 하는가?

직접 마이크로 서비스 찾기  
![1](https://user-images.githubusercontent.com/12209348/107191362-64146f00-6a2f-11eb-8be7-a160a8af5146.PNG)



여러 인스턴스가 있는 마이크로서비스 직접 검색  
![2](https://user-images.githubusercontent.com/12209348/107191365-65459c00-6a2f-11eb-9598-262db8c643aa.PNG)



서비스 발견은 무엇인가?
 - 서비스 발견  
 실행 시점에 한 마이크로서비스가 소비할 것을 목적으로 다른 마이크로서비스의 물리적 위치를 얻을 수 있는 수단을 뜻함.  
 서비스 발견을 제공하려면 서비스 레지스트리를 사용해야한다. 레지스트리가 없으면 서비스 발견 과정에서 URL을 가져올 장소가 없을 것이다.
 
 1. 지불 마이크로서비스는 알려진 서비스 레지스트리에게 스트라이프 마이크로서비스의 위치를 요청한다.
 2. 서비스 레지스트리는 현재 사용 가능한 모든 스트라이프 인스턴스를 반환한다.
 3. 지불 MSA는 서비스 레지스트리에서 얻은 스트라이프 MSA인스턴스에게 요청한다.
 4. 지불 MSA는 스트라이프MSA가 돌려주는 응답을 받는다.
 
 
