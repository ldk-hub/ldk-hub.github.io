---
# 포스트제목
title: "독후감 - 엔터프라이즈 자바 마이크로서비스 내용정리 "
# 포스팅 작성자
author: ["이동옥"] 
# 포스팅 공개일 - 정렬기준 포스팅날짜순서에 따라 기재됨.(주의 미래날짜는 기입X)
date: 2020-08-18 08:26:28 -0400
# 블로그 메인페이지에 썸네일과 함께 노출될 텍스트 설정 일정 길이를 초과하면 잘려서 표시됨.
# abstract:
# 태그를 입력
tags: ["MSA","마이크로서비스아키텍처","스프링클라우드"]
categories: JAVA
# 대표 이미지를 입력합니다. 이미지 업로드 위치는 아래에 기술합니다.
# image: /assets/images/posts/nerdfactory-documentation-history/main.jpg
# 포스트의 초안 여부를 입력합니다. "no" 로 입력할 경우 공개됩니다.
draft: "no"
toc: true
---
![gg](https://user-images.githubusercontent.com/12209348/100605351-26b6a580-334b-11eb-9785-7e1e5d79dbd0.PNG)

## msa를 공부하게 된 계기
요즘 다양한 플랫폼에서 클라우드 기반전략으로 시스템을 전향하고 있는추세였다. 내가근무했던 회사역시 클라우드화로 전향하기 시작했었고 클라우드 운영을 진행하는 과정에서 msa에 대한 관심이 생겼다.  
무턱대고 구글링을하면서 프로젝트를 진행하려했으나 기본이 탄탄하지 못하다는 생각이 들게 되면서 입문서를 통해 기초를 탄탄하게 쌓기위해 후기가 가장좋았던 입문서를 찾아 구매하게 되었다.   

## 책을 읽기전 중요단락  
책에서 주요내용으로 꼽는 4가지 큰 단락은 이와같다.  
 - 마이크로서비스 모델  
 - 클라우드 네이티브 개발  
 - 내고장성 전략과 모니터링 전략  
 - 개발을 마친 애플리케이션 보안 추가  
 
 - 엔터프라이즈 자바  
  API의 모음과 그 구현을 뜻함. -> UI부터 아랫단의 데이터베이스에이르기까지의 범위를 뜻함.  

## 모노리스 문제점  
 - 각컴포넌트의 규모 변경 불가  
 - 개별 컴포넌트의 성능 저하  
 - 개별 컴포넌트를 따로 전개 불가  
 - 코드 복잡도 증가  
 - 테스트 부정확도 증가  


## 정석 마이크로 서비스 아키텍처 구조
![11](https://user-images.githubusercontent.com/12209348/100836552-d78b8480-34b2-11eb-86f6-db4c323c51a4.PNG)

## 분산에 신경써야하는이유
 - 서비스 위치가 무관해짐  
 - 서비스가언어와 무관해짐  
 - 서비스전개규모가 작고 한가지 목적을 위해 전개됨.  
 - 새로운 서비스는 기존 서비스 기능을 재조합하는 방식  


## 마이크로서비스 문제점
- 서비스 독립성은 우수하지만 서비스간 서로연결하기는 어렵다.
  IP가아닌 논리적 네이밍을 가지고 서비스를 찾는다. 이를 서비스발견(서비스디스커버리라고함)
- 서비스 실패시 전체를 중단하지 않고 서비스 기능을 줄이면서 애플리케이션을 지속할 수단이필요하다.
  실패시 대안을제공하기위해 내고장성(폴트톨레런스)과 서비스탄력성(서비스 리슬라이스)이필요하다.
- 모노리스 운영 대비 < 마이크로서비스 운영의 부하가 더큼 
  그래서 이를 개선하기 위한 모니터링 자동화가 필요하다. 

마이크로서비스 개발은 개발난이도가 높음.

## 지속적인 통합, 지속적인 전달 (CI/CD)
 - 지속적인 통합(CI)
   소스 변경,커밋시 항상 새로 빌드되면서 관련된 테스트가 모두 수행된다는의미
   테스트가 충분하면 CI사용시 어떤 변경이 문제점인지 빠르게 인지할수 있음.
 - 지속적인 전달(CD)
   애플리케이션에 대한 변경이 지속적으로 프로덕션을 포함하는 여러 환경 사이에 전달되면서 
   변경한내용이 신속하게 고객에게 전달되도록 보장해주는것을 의미
   
## 모노리스에서 MSA전환시 사용되는 패턴
 - 도메인 주소 설계(DDD)
   기존의 프로세스에서 도메인모델 분리를 깔끔하게 해야하는데 이는 한계와 많은 어려움이 있다.
   그래서 소유자중심으로 구분하는데 이벤트소싱의 패턴을 사용하여 문제를해결해야한다.
  - 이벤트소싱 
   애플리케이션의 모든 상태 변경을을 이벤트로 발사하는기법 보통 이벤트들은 미리정해진 형태의 로그에 기록한다.
   이벤트를 저장한 로그를 사용해서 전체 데이터베이스를 재구축하거나 외부 도메인 모델 중 일부분을 전달할때 사용한다.
   
1. 빅뱅패턴
 - 가장난이도높은 패턴으로 기존 모노리스의 모든 부분을 하나하나 분리해서 마이크로 서비스로 변환하는 과정을 거친다.  
   마지막에 모노리스에서 마이크로 서비스로 모든 시스템이 전체적으로 이동한다.  
 - 전체적으로 모든 시스템을 전개해야하기 때문에 빅뱅이라는 이름과 함께 시간적 소요가 많이든다. 모노리스 구성만큼 소요됨.  
 - 대부분에서 빅뱅패턴은 권장하지 않음, 특히 MSA경험이없는 기업에서는 리스크가 너무 크기때문에 비추한다.  
 
2. 스트랭글러 패턴
 - 기존 서비스에서 하나씩 점진적으로 시스템을 구성하는 방식이다.
 - 기존 모노리스 환경을 유지하면서 MSA를 조금씩 늘려간다.
 - 장기적인 작업으로 빅뱅패턴보다 시간이 소요된다. 하지만 기존의 서비스에 대한 리스크는 훨씬 줄어든다.
 - 조금씩 구성하면서 상황을 모니터링하면서 문제는 조정하면서 안정화를 거듭해나갈수 있다.
 
3. 하이브리드 패턴
 - 저자의 의견은 가장 많이사용되는 패턴으로 꼽힌다고 한다.
 - 스트랭글러패턴과 비슷한 형태로 시작한다. 차이점은 모노리스를 없애지않는다는점이다.
 - 모노리스 안에 몇가지 기능을 유지하고 그 기능을 MSA에 통합하는방법이다. 
 
 * 사용자는 브라우저에서 자신이 보고 싶은 애플리케이션의 뷰를 요청한다.
 * 뷰는 자신을 만들어내기 위한 필요정보를 얻기 위해 컨트롤러를 호출한다.
 * 컨트롤러는 비즈니스 서비스를 호출한다. 컨트롤러는 여러 소스에서 얻은 데이터를 통합할수있다.
 * 게이트웨이는 미리 정의된 라우팅 규칙에 따라 요청을 적절한 MS에 전달한다.(MS 는 마이크로서비스라함.)
 * MS는 요청을 받고 자체처리를 진행한 후 다른 MS를 호출한다.
 * MS 사슬의 맨 마지막에 있는  MS는 데이터 저장소 계층과 상호작용해 레코드를 읽거나 쓸수있다.
 
 ### 하이브리드 아키텍처(이해를 위한 구성도)

   
